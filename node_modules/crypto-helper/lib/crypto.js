/**
 * Module dependencies
 */
var crypto = require('crypto');
var fs = require('fs');

/**
 * encrypt by hash algorithm
 *
 * @param {String} str String need to encrypt
 * @param {String} algorithm Which hash algorithm
 * @param {String} input_coding Default is utf8
 * @param {String} output_coding Default is hex
 */
exports.hash = function (str, algorithm, input_coding, output_coding) {
  var support = crypto.getHashes();
  if (!support.indexOf(algorithm)) {
    var msg = 'Your system do not support ' + algorithm + ' hash algorithm!';
    throw new Error(msg);
  }

  algorithm = algorithm || 'md5';
  var hash = crypto.createHash(algorithm);
  input_coding = input_coding || 'utf8';
  output_coding = output_coding || 'hex';
  hash.update(str, input_coding);
  return hash.digest(output_coding);
};

/**
 * encrypt by hmac algorithm
 *
 * @param {String} str String need to encrypt
 * @param {String} algorithm Which Algorithm
 * @param {String} key Key file position
 * @param {String} encoding
 */
exports.hmac = function (str, key, algorithm, encoding) {
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  algorithm = algorithm || 'sha1';

  var hmac = crypto.createHmac(algorithm, key);
  encoding = encoding || 'hex';
  hmac.update(str);
  return hmac.digest(encoding);
};

/**
 * encrypt by cipher
 *
 * @param {String} str
 * @param {String} algorithm
 * @param {String} key
 * @param {String} input_coding
 * @param {String} output_coding
 */
exports.cipher = function (str, key, algorithm, input_coding, output_coding) {
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  algorithm = algorithm || 'aes192';
  input_coding = input_coding || 'utf8';
  output_coding = output_coding || 'hex';

  var cipher = crypto.createCipher(algorithm, key);
  cipher.update(str, input_coding, output_coding);
  return cipher.final(output_coding);
};

/**
 * decrypt by decipher
 *
 * @param {String} str
 * @param {String} algorithm
 * @param {String} key
 * @param {String} input_coding
 * @param {String} output_coding
 */
exports.decipher = function (str, key, algorithm, input_coding, output_coding) {
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  algorithm = algorithm || 'aes192';
  input_coding = input_coding || 'hex';
  output_coding = output_coding || 'utf8';

  var decipher = crypto.createDecipher(algorithm, key);
  decipher.update(str, input_coding, output_coding);
  return decipher.final(output_coding);
}

/**
 * sign string with privat pem
 *
 * @param {String} str String need to sign
 * @param {String} algorithm Sign algorithm
 * @param {String} private_key
 * @param {String} output_coding
 */
exports.sign = function (str, private_key, algorithm, output_coding) {
  private_key = fs.readFileSync(private_key).toString('ascii');
  algorithm = algorithm || 'RSA-SHA256';
  output_coding = output_coding || 'hex';

  var sign = crypto.createSign(algorithm);
  sign.update(str);
  return sign.sign(private_key, output_coding);
};

/**
 * verify the sign with public pem
 *
 * @param {String} str 
 * @param {String} verifyStr String need to verify
 * @param {String} algorithm
 * @param {String} public_key
 * @param {String} output_coding
 */
exports.verify = function (str, verifyStr, public_key, algorithm, signature_format) {
  public_key = fs.readFileSync(public_key).toString('ascii');
  algorithm = algorithm || 'RSA-SHA256';
  signature_format = signature_format || 'hex';

  var verify = crypto.createVerify(algorithm);
  verify.update(str);
  return verify.verify(public_key, verifyStr, 'hex');
}