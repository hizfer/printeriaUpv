/* ****** automatically generated by jscover - do not edit ******/
if (typeof _$jscoverage === 'undefined') { _$jscoverage = {}; }
/* ****** end - do not edit ******/
function BranchData() {
    this.position = -1;
    this.nodeLength = -1;
    this.src = null;
    this.evalFalse = 0;
    this.evalTrue = 0;

    this.init = function(position, nodeLength, src) {
        this.position = position;
        this.nodeLength = nodeLength;
        this.src = src;
        return this;
    }

    this.ranCondition = function(result) {
        if (result)
            this.evalTrue++;
        else
            this.evalFalse++;
    };

    this.pathsCovered = function() {
        var paths = 0;
        if (this.evalTrue > 0)
          paths++;
        if (this.evalFalse > 0)
          paths++;
        return paths;
    };

    this.covered = function() {
        return this.evalTrue > 0 && this.evalFalse > 0;
    };

    this.toJSON = function() {
        return '{"position":' + this.position
            + ',"nodeLength":' + this.nodeLength
            + ',"src":' + jscoverage_quote(this.src)
            + ',"evalFalse":' + this.evalFalse
            + ',"evalTrue":' + this.evalTrue + '}';
    };

    this.message = function() {
        if (this.evalTrue === 0 && this.evalFalse === 0)
            return 'Condition never evaluated         :\t' + this.src;
        else if (this.evalTrue === 0)
            return 'Condition never evaluated to true :\t' + this.src;
        else if (this.evalFalse === 0)
            return 'Condition never evaluated to false:\t' + this.src;
        else
            return 'Condition covered';
    };
}

BranchData.fromJson = function(jsonString) {
    var json = eval('(' + jsonString + ')');
    var branchData = new BranchData();
    branchData.init(json.position, json.nodeLength, json.src);
    branchData.evalFalse = json.evalFalse;
    branchData.evalTrue = json.evalTrue;
    return branchData;
};

BranchData.fromJsonObject = function(json) {
    var branchData = new BranchData();
    branchData.init(json.position, json.nodeLength, json.src);
    branchData.evalFalse = json.evalFalse;
    branchData.evalTrue = json.evalTrue;
    return branchData;
};

function buildBranchMessage(conditions) {
    var message = 'The following was not covered:';
    for (var i = 0; i < conditions.length; i++) {
        if (conditions[i] !== undefined && conditions[i] !== null && !conditions[i].covered())
          message += '\n- '+ conditions[i].message();
    }
    return message;
};

function convertBranchDataConditionArrayToJSON(branchDataConditionArray) {
    var array = [];
    var length = branchDataConditionArray.length;
    for (var condition = 0; condition < length; condition++) {
        var branchDataObject = branchDataConditionArray[condition];
        if (branchDataObject === undefined || branchDataObject === null) {
            value = 'null';
        } else {
            value = branchDataObject.toJSON();
        }
        array.push(value);
    }
    return '[' + array.join(',') + ']';
}

function convertBranchDataLinesToJSON(branchData) {
    if (branchData === undefined) {
        return '[]'
    }
    var array = [];
    var length = branchData.length;
    for (var line = 0; line < length; line++) {
        var branchDataObject = branchData[line];
        if (branchDataObject === undefined || branchDataObject === null) {
            value = 'null';
        } else {
            value = convertBranchDataConditionArrayToJSON(branchDataObject);
        }
        array.push(value);
    }
    return '[' + array.join(',') + ']';
}

function convertBranchDataLinesFromJSON(jsonObject) {
    if (jsonObject === undefined) {
        return [];
    }
    var length = jsonObject.length;
    for (var line = 0; line < length; line++) {
        var branchDataJSON = jsonObject[line];
        if (branchDataJSON !== null) {
            for (var conditionIndex = 0; conditionIndex < branchDataJSON.length; conditionIndex ++) {
                var condition = branchDataJSON[conditionIndex];
                if (condition !== null) {
                    branchDataJSON[conditionIndex] = BranchData.fromJsonObject(condition);
                }
            }
        }
    }
    return jsonObject;
}
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
      top.opener._$jscoverage.branchData = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
      top._$jscoverage.branchData = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    this._$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (! this._$jscoverage) {
  this._$jscoverage = {};
  this._$jscoverage.branchData = {};
}
if (! _$jscoverage['crypto.js']) {
  _$jscoverage['crypto.js'] = [];
  _$jscoverage['crypto.js'][4] = 0;
  _$jscoverage['crypto.js'][5] = 0;
  _$jscoverage['crypto.js'][15] = 0;
  _$jscoverage['crypto.js'][16] = 0;
  _$jscoverage['crypto.js'][17] = 0;
  _$jscoverage['crypto.js'][18] = 0;
  _$jscoverage['crypto.js'][19] = 0;
  _$jscoverage['crypto.js'][22] = 0;
  _$jscoverage['crypto.js'][23] = 0;
  _$jscoverage['crypto.js'][24] = 0;
  _$jscoverage['crypto.js'][25] = 0;
  _$jscoverage['crypto.js'][26] = 0;
  _$jscoverage['crypto.js'][27] = 0;
  _$jscoverage['crypto.js'][38] = 0;
  _$jscoverage['crypto.js'][39] = 0;
  _$jscoverage['crypto.js'][40] = 0;
  _$jscoverage['crypto.js'][42] = 0;
  _$jscoverage['crypto.js'][43] = 0;
  _$jscoverage['crypto.js'][44] = 0;
  _$jscoverage['crypto.js'][45] = 0;
  _$jscoverage['crypto.js'][57] = 0;
  _$jscoverage['crypto.js'][58] = 0;
  _$jscoverage['crypto.js'][59] = 0;
  _$jscoverage['crypto.js'][60] = 0;
  _$jscoverage['crypto.js'][61] = 0;
  _$jscoverage['crypto.js'][63] = 0;
  _$jscoverage['crypto.js'][64] = 0;
  _$jscoverage['crypto.js'][65] = 0;
  _$jscoverage['crypto.js'][77] = 0;
  _$jscoverage['crypto.js'][78] = 0;
  _$jscoverage['crypto.js'][79] = 0;
  _$jscoverage['crypto.js'][80] = 0;
  _$jscoverage['crypto.js'][81] = 0;
  _$jscoverage['crypto.js'][83] = 0;
  _$jscoverage['crypto.js'][84] = 0;
  _$jscoverage['crypto.js'][85] = 0;
  _$jscoverage['crypto.js'][96] = 0;
  _$jscoverage['crypto.js'][97] = 0;
  _$jscoverage['crypto.js'][98] = 0;
  _$jscoverage['crypto.js'][99] = 0;
  _$jscoverage['crypto.js'][101] = 0;
  _$jscoverage['crypto.js'][102] = 0;
  _$jscoverage['crypto.js'][103] = 0;
  _$jscoverage['crypto.js'][115] = 0;
  _$jscoverage['crypto.js'][116] = 0;
  _$jscoverage['crypto.js'][117] = 0;
  _$jscoverage['crypto.js'][118] = 0;
  _$jscoverage['crypto.js'][120] = 0;
  _$jscoverage['crypto.js'][121] = 0;
  _$jscoverage['crypto.js'][122] = 0;
}
_$jscoverage['crypto.js'].source = ["/**"," * Module dependencies"," */","var crypto = require('crypto');","var fs = require('fs');","","/**"," * encrypt by hash algorithm"," *"," * @param {String} str String need to encrypt"," * @param {String} algorithm Which hash algorithm"," * @param {String} input_coding Default is utf8"," * @param {String} output_coding Default is hex"," */","exports.hash = function (str, algorithm, input_coding, output_coding) {","  var support = crypto.getHashes();","  if (!support.indexOf(algorithm)) {","    var msg = 'Your system do not support ' + algorithm + ' hash algorithm!';","    throw new Error(msg);","  }","","  algorithm = algorithm || 'md5';","  var hash = crypto.createHash(algorithm);","  input_coding = input_coding || 'utf8';","  output_coding = output_coding || 'hex';","  hash.update(str, input_coding);","  return hash.digest(output_coding);","};","","/**"," * encrypt by hmac algorithm"," *"," * @param {String} str String need to encrypt"," * @param {String} algorithm Which Algorithm"," * @param {String} key Key file position"," * @param {String} encoding"," */","exports.hmac = function (str, key, algorithm, encoding) {","  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;","  algorithm = algorithm || 'sha1';","","  var hmac = crypto.createHmac(algorithm, key);","  encoding = encoding || 'hex';","  hmac.update(str);","  return hmac.digest(encoding);","};","","/**"," * encrypt by cipher"," *"," * @param {String} str"," * @param {String} algorithm"," * @param {String} key"," * @param {String} input_coding"," * @param {String} output_coding"," */","exports.cipher = function (str, key, algorithm, input_coding, output_coding) {","  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;","  algorithm = algorithm || 'aes192';","  input_coding = input_coding || 'utf8';","  output_coding = output_coding || 'hex';","","  var cipher = crypto.createCipher(algorithm, key);","  cipher.update(str, input_coding, output_coding);","  return cipher.final(output_coding);","};","","/**"," * decrypt by decipher"," *"," * @param {String} str"," * @param {String} algorithm"," * @param {String} key"," * @param {String} input_coding"," * @param {String} output_coding"," */","exports.decipher = function (str, key, algorithm, input_coding, output_coding) {","  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;","  algorithm = algorithm || 'aes192';","  input_coding = input_coding || 'hex';","  output_coding = output_coding || 'utf8';","","  var decipher = crypto.createDecipher(algorithm, key);","  decipher.update(str, input_coding, output_coding);","  return decipher.final(output_coding);","}","","/**"," * sign string with privat pem"," *"," * @param {String} str String need to sign"," * @param {String} algorithm Sign algorithm"," * @param {String} private_key"," * @param {String} output_coding"," */","exports.sign = function (str, private_key, algorithm, output_coding) {","  private_key = fs.readFileSync(private_key).toString('ascii');","  algorithm = algorithm || 'RSA-SHA256';","  output_coding = output_coding || 'hex';","","  var sign = crypto.createSign(algorithm);","  sign.update(str);","  return sign.sign(private_key, output_coding);","};","","/**"," * verify the sign with public pem"," *"," * @param {String} str "," * @param {String} verifyStr String need to verify"," * @param {String} algorithm"," * @param {String} public_key"," * @param {String} output_coding"," */","exports.verify = function (str, verifyStr, public_key, algorithm, signature_format) {","  public_key = fs.readFileSync(public_key).toString('ascii');","  algorithm = algorithm || 'RSA-SHA256';","  signature_format = signature_format || 'hex';","","  var verify = crypto.createVerify(algorithm);","  verify.update(str);","  return verify.verify(public_key, verifyStr, 'hex');","}"];
_$jscoverage['crypto.js'][4]++;
var crypto = require('crypto');
_$jscoverage['crypto.js'][5]++;
var fs = require('fs');
_$jscoverage['crypto.js'][15]++;
exports.hash = function(str, algorithm, input_coding, output_coding) {
  _$jscoverage['crypto.js'][16]++;
  var support = crypto.getHashes();
  _$jscoverage['crypto.js'][17]++;
  if (!support.indexOf(algorithm)) {
    _$jscoverage['crypto.js'][18]++;
    var msg = 'Your system do not support ' + algorithm + ' hash algorithm!';
    _$jscoverage['crypto.js'][19]++;
    throw new Error(msg);
  }
  _$jscoverage['crypto.js'][22]++;
  algorithm = algorithm || 'md5';
  _$jscoverage['crypto.js'][23]++;
  var hash = crypto.createHash(algorithm);
  _$jscoverage['crypto.js'][24]++;
  input_coding = input_coding || 'utf8';
  _$jscoverage['crypto.js'][25]++;
  output_coding = output_coding || 'hex';
  _$jscoverage['crypto.js'][26]++;
  hash.update(str, input_coding);
  _$jscoverage['crypto.js'][27]++;
  return hash.digest(output_coding);
};
_$jscoverage['crypto.js'][38]++;
exports.hmac = function(str, key, algorithm, encoding) {
  _$jscoverage['crypto.js'][39]++;
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  _$jscoverage['crypto.js'][40]++;
  algorithm = algorithm || 'sha1';
  _$jscoverage['crypto.js'][42]++;
  var hmac = crypto.createHmac(algorithm, key);
  _$jscoverage['crypto.js'][43]++;
  encoding = encoding || 'hex';
  _$jscoverage['crypto.js'][44]++;
  hmac.update(str);
  _$jscoverage['crypto.js'][45]++;
  return hmac.digest(encoding);
};
_$jscoverage['crypto.js'][57]++;
exports.cipher = function(str, key, algorithm, input_coding, output_coding) {
  _$jscoverage['crypto.js'][58]++;
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  _$jscoverage['crypto.js'][59]++;
  algorithm = algorithm || 'aes192';
  _$jscoverage['crypto.js'][60]++;
  input_coding = input_coding || 'utf8';
  _$jscoverage['crypto.js'][61]++;
  output_coding = output_coding || 'hex';
  _$jscoverage['crypto.js'][63]++;
  var cipher = crypto.createCipher(algorithm, key);
  _$jscoverage['crypto.js'][64]++;
  cipher.update(str, input_coding, output_coding);
  _$jscoverage['crypto.js'][65]++;
  return cipher.final(output_coding);
};
_$jscoverage['crypto.js'][77]++;
exports.decipher = function(str, key, algorithm, input_coding, output_coding) {
  _$jscoverage['crypto.js'][78]++;
  key = fs.lstatSync(key).isFile() ? fs.readFileSync(key).toString('ascii') : key;
  _$jscoverage['crypto.js'][79]++;
  algorithm = algorithm || 'aes192';
  _$jscoverage['crypto.js'][80]++;
  input_coding = input_coding || 'hex';
  _$jscoverage['crypto.js'][81]++;
  output_coding = output_coding || 'utf8';
  _$jscoverage['crypto.js'][83]++;
  var decipher = crypto.createDecipher(algorithm, key);
  _$jscoverage['crypto.js'][84]++;
  decipher.update(str, input_coding, output_coding);
  _$jscoverage['crypto.js'][85]++;
  return decipher.final(output_coding);
};
_$jscoverage['crypto.js'][96]++;
exports.sign = function(str, private_key, algorithm, output_coding) {
  _$jscoverage['crypto.js'][97]++;
  private_key = fs.readFileSync(private_key).toString('ascii');
  _$jscoverage['crypto.js'][98]++;
  algorithm = algorithm || 'RSA-SHA256';
  _$jscoverage['crypto.js'][99]++;
  output_coding = output_coding || 'hex';
  _$jscoverage['crypto.js'][101]++;
  var sign = crypto.createSign(algorithm);
  _$jscoverage['crypto.js'][102]++;
  sign.update(str);
  _$jscoverage['crypto.js'][103]++;
  return sign.sign(private_key, output_coding);
};
_$jscoverage['crypto.js'][115]++;
exports.verify = function(str, verifyStr, public_key, algorithm, signature_format) {
  _$jscoverage['crypto.js'][116]++;
  public_key = fs.readFileSync(public_key).toString('ascii');
  _$jscoverage['crypto.js'][117]++;
  algorithm = algorithm || 'RSA-SHA256';
  _$jscoverage['crypto.js'][118]++;
  signature_format = signature_format || 'hex';
  _$jscoverage['crypto.js'][120]++;
  var verify = crypto.createVerify(algorithm);
  _$jscoverage['crypto.js'][121]++;
  verify.update(str);
  _$jscoverage['crypto.js'][122]++;
  return verify.verify(public_key, verifyStr, 'hex');
};
