#! /usr/bin/env python2import sys, subprocess, collections, resbml= 0class sencillo:    """    A python version of facile with options:    -M for a mathematica script for algrebraic manipulation    -y for python scripts to simulate ODEs with scipy    -m for matlab scripts to simulate ODES    -s for stochastic simulations with StochKit2    -S for SBML (libsbml must be installed)    The .eqn has a similar format to the facile files. Examples of mass action reactions are    binding: E + S <-> C ; 10; 2    conversion: C -> P + E ; k= 1.2    D -> null ; k    null -> P ; 34    Parameters can be defined as constants that must not be functions of chemical species:    parameter n= 300    Variables can be functions of chemical species:    variable gamma= gamma_max*E/(K_g + E)    Mass action can be avoided by specifying reaction rates:    C <=> F ; E*D*h ; j*n    or    variable r= u*F*E    null => Z ; r    A -> B ; r    if a variable is defined.    Note that for mass action, reactions with multiple occurences of the same reactant should be written explicitly. For example,    A + A -> A2 ; f    C -> A + A + E ; b (note that the two identical products should come first)    For those that do not follow mass action, reactions such as    n A => B ; A/(A+K)    are allowed, and A will decrease by n*A/(A+K) for an ODE model of this example.    Note further that variable names should be defined in order: if variable beta depends on variable alpha then variable alpha must be defined before variable beta.    Initial conditions are specified by, for example,    A= 1    and any chemical species not specified will have an initial condition of zero.    """    def __init__(self, fname):        self.name= fname.split('.')[0]        reactions= {}        species= {}        parameters= []        variables= []        nononames= 0        for line in open(fname):            line= line.rstrip()            if (not line or line == 'INIT' or line == 'EQN' or line[0] == '#'                or line[0] == '%'):                # ignore section headings and comments                continue            else:                # remove any trailing semi-colons                if line[-1] == ';':                    line= line[:-1]                # remove any inline comments                if line.find('#') > -1:                    line= line[:line.find('#')]                # analyze chemical equation                if ';' in line:                    # process chemical reaction                    bits= line.split(';')                    # assign reaction name                    if ':' in bits[0]:                        # reaction name is given                        bitsofbits= bits[0].split(':')                        reactionname= bitsofbits[0]                        chemeq= self.rmwhitespace(bitsofbits[1])                    else:                        # no reaction name: assign a numeric name                        reactionname= str(nononames)                        nononames += 1                        chemeq= bits[0]                    # find rates of reaction                    chemrates= []                    for crate in bits[1:]:                        chemrates.append(self.rmwhitespace(crate))                    # add reactions to dictionary of reactions                    if '<->' in chemeq:                        # reversible reaction: make two elementary reactions                        chems= chemeq.split('<->')                        chemeqf= chems[0] + '->' + chems[1]                        chemeqb= chems[1] + '->' + chems[0]                    elif '<=>' in chemeq:                        # reversible reaction: make two elementary reactions                        chems= chemeq.split('<=>')                        chemeqf= chems[0] + '=>' + chems[1]                        chemeqb= chems[1] + '=>' + chems[0]                    if '<->' in chemeq or '<=>' in chemeq:                        self.addreaction(reactions, species, reactionname + '_f',                                         chemeqf, chemrates[0])                        self.addreaction(reactions, species, reactionname + '_b',                                         chemeqb, chemrates[1])                    else:                        # irreversible reaction                        self.addreaction(reactions, species, reactionname, chemeq,                                         chemrates[0])                else:                    # not a reaction                    bits= line.split()                    if bits[0] == 'parameter':                        # add parameter to list of parameters                        parameters.append(' '.join(bits[1:]))                    elif bits[0] == 'variable':                        # add variables to list of variables                        variables.append(' '.join(bits[1:]))                    else:                        # analyze initial conditions                        bits= line.split('=')                        species[self.rmwhitespace(bits[0])]['initial amount']= self.rmwhitespace(bits[1])        # sort reactions so that rates with numerical values come first        reactions= collections.OrderedDict(sorted(reactions.items(),                                                  key= lambda x: x[1]['rate value']))        # sort species so that initial values with numerical values come first        species= collections.OrderedDict(sorted(species.items(),                                                key= lambda x: x[1]['initial amount']))        # store reactions and species        self.reactions= reactions        self.species= species        # convert variables to a dictionary        vardict= collections.OrderedDict()        for var in variables:            vname= self.rmwhitespace(var.split('=')[0])            vvalue= self.rmwhitespace(var.split('=')[1])            vardict[vname]= {'value' : vvalue}        self.variables= vardict        # add modifiers        for var in vardict.keys():            self.variables[var]['modifiers']= self.findmodifiers(vardict[var]['value'])        # convert parameters to a dictionary        pardict= {}        for par in parameters:            pardict[self.rmwhitespace(par.split('=')[0])]= self.rmwhitespace(par.split('=')[1])        self.parameters= pardict    #######    # some utility functions    #######    def addreaction(self, r, s, name, chemeq, chemrates):        '''        Takes a reaction and updates local copies of the reactions and species dictionaries.        '''        if '->' in chemeq:            bits= chemeq.split('->')        else:            bits= chemeq.split('=>')        # find rate constant        rbits= chemrates.split('=')        if len(rbits) == 1:            # no value given for rate constant            rbits.append('')        # find reactants and number of times a reactant appears in chemeq        rs= bits[0].split('+')        reacs= range(len(rs))        reacs_n= {}        for (c, rsi) in enumerate(rs):            rsbd= rsi.split()            if len(rsbd) == 2:                # reactant occurs more than once                reacs[c]= rsbd[1]                reacs_n[rsbd[1]]= rsbd[0]                if '->' in chemeq:                    print(' Warning: reactant occurs more than once in \n\t' + chemeq)            else:                # reactant occurs once                reacs[c]= rsbd[0]        # find products and number of times a product appears in chemeq        ps= bits[1].split('+')        prods= range(len(ps))        prods_n= {}        for (c, psi) in enumerate(ps):            psbd= psi.split()            if len(psbd) == 2:                # product occurs more than once                prods[c]= psbd[1]                prods_n[psbd[1]]= psbd[0]                if '->' in chemeq:                    print (' Warning: product occurs more than once in \n' + '\t' + chemeq)            else:                # product occurs once                prods[c]= psbd[0]        # add to dictionary of reactions        r[name]= {'reactants' : reacs, 'products' : prods, 'rate value' : rbits[1],                  'rate constant' : rbits[0], 'name' : chemeq}        # birth and death reactions are special        if 'null' in bits[0]:            # birth reaction            r[name]['reactants']= ''        elif 'null' in bits[1]:            # death reaction            r[name]['products']= ''        # calculate mass action rate of reaction        if '->' in chemeq:            r[name]['mass action']= 1            ratec= r[name]['rate constant']            if '+' in ratec or '-' in ratec:                # add brackets to avoid ambiguities                ratec= '(' + ratec + ')'            if 'null' in bits[0]:                # birth reaction                rate= ratec            else:                # first-order reaction                rate= ratec + '*' + r[name]['reactants'][0]                # second-order reaction                if len(r[name]['reactants']) > 1:                    rate += '*' + r[name]['reactants'][1]        else:            # the rate is specifed for => reactions            r[name]['mass action']= 0            if '+' in rbits[0] or '-' in rbits[0]:                # add brackets to avoid ambiguities                rate= '(' + rbits[0] + ')'            else:                rate= rbits[0]        # add to dictionary of species        for species in r[name]['reactants']:            if species != '' and species != 'null':                if reacs_n.has_key(species):                    # a => reaction with multiple occurences of one reactant                    frate= rate + '*' + reacs_n[species]                else:                    # a normal reaction                    frate= rate                if s.has_key(species):                    s[species]['death'] += '-' + frate                else:                    s[species]= {'birth' : '', 'death' : '-' + frate,                                 'initial amount' : '0'}        for species in r[name]['products']:            if species != '' and species != 'null':                if prods_n.has_key(species):                    # a => reaction with multiple occurences of one product                    frate= rate + '*' + prods_n[species]                else:                    # a normal reaction                    frate= rate                if s.has_key(species):                    s[species]['birth'] += '+' + frate                else:                    s[species]= {'birth' : '+' + frate, 'death' : '',                                 'initial amount' : '0'}    def findmodifiers(self, rate, exclude= []):        '''        Determines the species that are present in the expression of a chemical rate. These so-called modifiers are necessary for SBML. Note that some species may be indirectly acting as modifiers through variables.        '''        bits= re.sub(r'[\^*\+-\/\(\)]', ';', rate).split(';')        species= self.species.keys()        varnames= self.variables.keys()        mods= []        for b in bits:            bb= self.rmwhitespace(b)            if bb in species:                mods.append(bb)            elif bb in varnames:                mods += self.variables[bb]['modifiers']        # return unique list        mods= list(set(mods))        # carry out exclusions if required        for rem in exclude:            mods.remove(rem)        return list(set(mods))    def isfloat(self, s):        try:            float(s)        except ValueError:            return False        return True    def rmwhitespace(self, s):        return ''.join(s.split())    #####    def printmathematica(self, ofile):        s= self.species        out= open(ofile + '.ma', 'w')        for sname in s.keys():            outstring= ('d' + sname + 'dt= ' + s[sname]['birth']                        + s[sname]['death'] + ';\n')            out.write(outstring)        out.close()    #####    def printodes(self, out, otype):        p= self.parameters        r= self.reactions        s= self.species        v= self.variables        if otype == 'python':            deliml= '['            delimr= ']'            stp= ''            inc= 0        elif otype == 'matlab':            deliml= '('            delimr= ')'            stp= ';'            inc= 1        # define the vector of rates        c= 0        for rname in r.keys():            # only define rates that have had values given            if r[rname]['rate value'] != '':                out.write('\t' + r[rname]['rate constant'] + '= rates' \                          + deliml + str(c+inc) + delimr + stp +  '\n')                c += 1        out.write('\n')        # define the vector of parameters        for (c, par) in enumerate(p.keys()):            out.write('\t' + par + '= parameters' + deliml \                      + str(c+inc) +  delimr + stp + '\n')        out.write('\n')        # define y as a vector of species        for (c, sname) in enumerate(s.keys()):            out.write('\t' + sname + '= y' + deliml + str(c+inc) + delimr + stp + '\n')        out.write('\n')        # print any variables        for var in v.keys():            if otype == 'python':                out.write('\t' + var + '= ' + v[var]['value'].replace('^', '**') + stp + '\n')            elif otype == 'matlab':                out.write('\t' + var + '= ' + v[var]['value'] + stp + '\n')        out.write('\n')        # print the differential equations        if otype == 'python':            out.write('\tdydt= np.empty(' + str(len(s)) + ')\n')        elif otype == 'matlab':            out.write('\tdydt(size(y,1),1)= 0;\n')        for (c, sname) in enumerate(s.keys()):            if otype == 'python':                out.write('\tdydt' + deliml + str(c+inc) + delimr + '= ' \                          + s[sname]['birth'].replace('^', '**') \                          + s[sname]['death'].replace('^', '**') + stp + '\n')            elif otype == 'matlab':                out.write('\tdydt' + deliml + str(c+inc) + delimr + '= ' \                          + s[sname]['birth'] + s[sname]['death'] + stp + '\n')    #####    def printdriver(self, out, otype):        p= self.parameters        r= self.reactions        s= self.species        v= self.variables        if otype == 'python':            deliml= 'np.asarray(['            delimr= '])'            stp= ''            fillc= ','            commt= '#'        elif otype == 'matlab':            deliml= '['            delimr= ']'            stp= ';'            fillc= ' '            commt= '%'        # define parameters        out.write(commt + ' parameters\n')        outstring= ''        for par in p.keys():            out.write(par + '= ' + p[par] + stp + '\n')            outstring += fillc + par        out.write('parameters= ' + deliml + outstring[1:] + delimr + stp + '\n\n')         # define rate constants        out.write(commt + ' define rate constants\n')        outstring= ''        for rname in r.keys():            # check that a rate value has been given before printing            if r[rname]['rate value'] != '':                out.write(r[rname]['rate constant'] + '= ' \                          + r[rname]['rate value'] + stp + '\n')                outstring += fillc + r[rname]['rate constant']        out.write('rates= ' + deliml + outstring[1:] + delimr + stp + '\n\n')        # define initial conditions        out.write(commt + ' define initial conditions\n')        outstring= '';        for sname in s.keys():            if self.isfloat(s[sname]['initial amount']):                out.write(sname + '_0= ' + s[sname]['initial amount'] + stp + '\n')            else:                # use initial amount defined earlier                out.write(sname + '_0= ' + s[sname]['initial amount'] + '_0' + stp + '\n')            outstring += fillc + sname + '_0'        out.write('init= ' + deliml + outstring[1:] + delimr + stp + '\n\n')    #####    def printpython(self, ofile):        s= self.species        out= open(ofile + '.py', 'w')        out.write('import numpy as np\n')        out.write('import matplotlib.pylab as plt\n')        out.write('from scipy.integrate import odeint\n\n')        # function for odeint        out.write('def ' + ofile + '(y, t, rates, parameters):\n\n')        self.printodes(out, 'python')        out.write('\n\treturn dydt\n')        # driver code        out.write('\n#######\n\n')        out.write('t= np.arange(0, 100, 10)\n\n')        self.printdriver(out, 'python')        out.write('# call odeint (note args must be a tuple) \n')        out.write('y= odeint(' + ofile + \                  ', init, t, args= (rates, parameters), mxstep= 10000)\n')        for (c, sname) in enumerate(s.keys()):            out.write(sname + '= y[:,' + str(c) + ']\n')        out.write('\n')    #####    def printmatlab(self, ofile):        s= self.species        # function for ode23        out= open(ofile + '_odes.m', 'w')        out.write('function dydt= ' + ofile + '_odes(t, y, rates, parameters)\n\n')        self.printodes(out, 'matlab')        out.close()        # driver file        out= open(ofile + 'Driver.m', 'w')        self.printdriver(out, 'matlab')        out.write('% call solver routine \n')        out.write('t0= 0;\n')        out.write('tf= NO_TIME_SPECIFIED;\n')        out.write('[t,y]= ode23s(@(t,y) ' + ofile + '_odes(t, y, rates, parameters), ' + \                  '[t0 tf], init);\n')        for (c, sname) in enumerate(s.keys()):            out.write(sname + '= y(:,' + str(c+1) + ');\n')        out.write('\n')        out.close()    #####    def printstochkit(self, ofile):        #### Variables not implemented        p= self.parameters        r= self.reactions        s= self.species        v= self.variables        out= open(ofile + '.xml', 'w')        # preliminary details        out.write('<Model>\n')        out.write('\t<Description>' + self.name + '</Description>\n')        out.write('\t<NumberOfReactions>' + str(len(r)) + '</NumberOfReactions>\n')        out.write('\t<NumberOfSpecies>' + str(len(s)) + '</NumberOfSpecies>\n')        # parameters        out.write('\t<ParametersList>\n')        for par in p.keys():            out.write('\t\t<Parameter>\n')            out.write('\t\t <Id>' + par + '</Id>\n')            out.write('\t\t <Expression>' + p[par]['value'] + '</Expression>\n')            out.write('\t\t</Parameter>\n')        out.write('\t</ParametersList>\n')        # reactions        out.write('\t<ReactionsList>\n')        for reac in r.keys():            out.write('\t\t<Reaction>\n')            out.write('\t\t <Id>' + reac + '</Id>\n')            out.write('\t\t <Description>' + r[reac]['name']+ '</Description>\n')            # rate            if r[reac]['mass action']:                out.write('\t\t <Type>mass-action</Type>\n')            else:                out.write('\t\t <Type>customized</Type>\n')                out.write('\t\t <PropensityFunction>' + r[reac]['rate constant']                          + '</PropensityFunction>\n')            # reactants            out.write('\t\t <Reactants>\n')            if len(r[reac]['reactants']) == 1:                if r[reac]['reactants'][0] != 'null':                    out.write('\t\t  <SpeciesReference id="' + r[reac]['reactants'][0] \                              + '" stoichiometry="1"/>\n')            else:                if r[reac]['reactants'][0] == r[reac]['reactants'][1]:                    out.write('\t\t  <SpeciesReference id="' + r[reac]['reactants'][0]                              + '" stoichiometry="2"/>\n')                else:                    out.write('\t\t  <SpeciesReference id="' + r[reac]['reactants'][0]                          + '" stoichiometry="1"/>\n')                    out.write('\t\t  <SpeciesReference id="' + r[reac]['reactants'][1]                          + '" stoichiometry="1"/>\n')            out.write('\t\t </Reactants>\n')            # products            out.write('\t\t <Products>\n')            if len(r[reac]['products']) == 1:                if r[reac]['products'][0] != 'null':                    out.write('\t\t  <SpeciesReference id="' + r[reac]['products'][0]                              + '" stoichiometry="1"/>\n')            else:                if r[reac]['products'][0] == r[reac]['products'][1]:                    if r[reac]['products'][0] == r[reac]['products'][2]:                        out.write('\t\t  <SpeciesReference id="' + r[reac]['products'][0]                                  + '" stoichiometry="3"/>\n')                    else:                        out.write('\t\t  <SpeciesReference id="' + r[reac]['products'][0]                                  + '" stoichiometry="2"/>\n')                else:                    for i in range(len(r[reac]['products'])):                        out.write('\t\t  <SpeciesReference id="' + r[reac]['products'][i]                          + '" stoichiometry="1"/>\n')            out.write('\t\t </Products>\n')            out.write('\t\t</Reaction>\n')        out.write('\t</ReactionsList>\n')        # species        out.write('\t<SpeciesList>\n')        for spec in s.keys():            out.write('\t\t<Species>\n')            out.write('\t\t <Id>' + spec + '</Id>\n')            out.write('\t\t <InitialPopulation>' + s[spec]['initial amount']                      + '</InitialPopulation>\n')            out.write('\t\t</Species>\n')        out.write('\t</SpeciesList>\n')        out.write('</Model>\n')        out.close()    ####    def printSBML(self, ofile):        if sbml:            p= self.parameters            r= self.reactions            s= self.species            v= self.variables            # preliminaries            document= libsbml.SBMLDocument(2,3) # SBML 2.3            model= document.createModel()            c= model.createCompartment()            c.setId('cell')            c.setVolume(1.0)            # create species            for spec in s.keys():                ss= model.createSpecies()                ss.setId(spec)                ss.setCompartment('cell')                ss.setInitialAmount(eval(s[spec]['initial amount']))            # create parameters            for par in p.keys():                pp= model.createParameter()                pp.setId(par)                pp.setConstant(True)                pp.setValue(eval(p[par]))            # variables must first be defined as parameters            for var in v.keys():                pp= model.createParameter()                pp.setId(var)                pp.setConstant(False)            # define all rate constants as parameters            for reac in r.keys():                rvalue= r[reac]['rate value']                if rvalue:                    # a new rate constant is defined                    newrate= r[reac]['rate constant']                    pp= model.createParameter()                    pp.setId(newrate)                    if self.isfloat(rvalue):                        # defined numerically                        pp.setConstant(True)                        pp.setValue(eval(rvalue))                    else:                        # defined algebraically                        pp.setConstant(False)                        vv= model.createAssignmentRule()                        value= libsbml.parseFormula(rvalue)                        vv.setVariable(newrate)                        vv.setMath(value)            # create variables            for var in v.keys():                vv= model.createAssignmentRule()                value= libsbml.parseFormula(v[var]['value'])                vv.setVariable(var)                vv.setMath(value)            # create reactions            for reac in r.keys():                rr= model.createReaction()                rr.setId('r_' + reac)                rr.setCompartment('cell')                rr.setReversible(False)                for i in range(len(r[reac]['reactants'])):                    rrr= rr.createReactant()                    rrr.setSpecies(r[reac]['reactants'][i])                for i in range(len(r[reac]['products'])):                    rrp= rr.createProduct()                    rrp.setSpecies(r[reac]['products'][i])                if r[reac]['mass action']:                    # find rate by mass action                    rrate= r[reac]['rate constant']                    for reactant in r[reac]['reactants']:                        rrate += '*'+reactant                    mods= self.findmodifiers(rrate, exclude= r[reac]['reactants'])                else:                    # rate already specified                    rrate= r[reac]['rate constant']                    mods= self.findmodifiers(rrate)                # add modifiers                for mod in mods:                    mdf= rr.createModifier()                    mdf.setSpecies(mod)                rrk= rr.createKineticLaw()                rrk.setFormula(rrate)            # write file            document.setModel(model)            libsbml.writeSBMLToFile(document, ofile + '.xml')        else:            print (' libSBML cannot be imported. SBML cannot be created.')#####if __name__ == '__main__':    if len(sys.argv) == 3:        fname= sys.argv[2]        ofile= fname.split('.')[0]        S= sencillo(fname)        key= sys.argv[1].split('-')[1]        if key == 'M':            S.printmathematica(ofile)        elif key == 'm':            S.printmatlab(ofile)        elif key ==  'y':            S.printpython(ofile)        elif key ==  's':            S.printstochkit(ofile)        elif key == 'S':            S.printSBML(ofile)        else:            print (sencillo.__doc__)    else:        print (sencillo.__doc__)